## API Report File for "web3-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { Address } from 'web3-utils';
import { BlockNumberOrTag } from 'web3-validator';
import { Bytes } from 'web3-utils';
import { EventEmitter } from 'events';
import { Filter } from 'web3-utils';
import { HexString } from 'web3-utils';
import { HexString256Bytes } from 'web3-utils';
import { HexString32Bytes } from 'web3-utils';
import { HexString8Bytes } from 'web3-utils';
import { HexStringBytes } from 'web3-utils';
import { HexStringSingleByte } from 'web3-utils';
import { JsonSchema } from 'web3-validator';
import { Numbers } from 'web3-utils';
import { Topic } from 'web3-utils';
import { Uint } from 'web3-utils';
import { Uint256 } from 'web3-utils';
import { ValidationSchemaInput } from 'web3-validator';
import { Web3Error } from 'web3-errors';

// @public (undocumented)
export type AccessList = AccessListEntry[];

// @public (undocumented)
export interface AccessListEntry {
	// (undocumented)
	readonly address?: Address;
	// (undocumented)
	readonly storageKeys?: HexString32Bytes[];
}

// @public (undocumented)
export interface BaseTransaction {
	// (undocumented)
	readonly chainId?: Uint;
	// (undocumented)
	readonly data?: HexStringBytes;
	// (undocumented)
	readonly gas: Uint;
	// (undocumented)
	readonly input: HexStringBytes;
	// (undocumented)
	readonly nonce: Uint;
	// (undocumented)
	readonly to?: Address | null;
	// (undocumented)
	readonly type: HexStringSingleByte;
	// (undocumented)
	readonly value: Uint;
}

// @public (undocumented)
export interface Block {
	// (undocumented)
	readonly baseFeePerGas?: Uint;
	// (undocumented)
	readonly difficulty?: Uint;
	// (undocumented)
	readonly extraData: HexStringBytes;
	// (undocumented)
	readonly gasLimit: Uint;
	// (undocumented)
	readonly gasUsed: Uint;
	// (undocumented)
	readonly hash: HexString32Bytes | null;
	// (undocumented)
	readonly logsBloom: HexString256Bytes | null;
	// (undocumented)
	readonly miner: HexString;
	// (undocumented)
	readonly mixHash: HexString32Bytes;
	// (undocumented)
	readonly nonce: Uint | null;
	// (undocumented)
	readonly number: Uint | null;
	// (undocumented)
	readonly parentHash: HexString32Bytes;
	// (undocumented)
	readonly receiptsRoot: HexString32Bytes;
	// (undocumented)
	readonly sha3Uncles: HexString32Bytes;
	// (undocumented)
	readonly size: Uint;
	// (undocumented)
	readonly stateRoot: HexString32Bytes;
	// (undocumented)
	readonly timestamp: Uint;
	// (undocumented)
	readonly totalDifficulty: Uint;
	// (undocumented)
	readonly transactions: TransactionHash[] | TransactionInfo[];
	// (undocumented)
	readonly transactionsRoot: HexString32Bytes;
	// (undocumented)
	readonly uncles: Uncles;
}

// @public (undocumented)
export interface BlockInput {
	// (undocumented)
	readonly baseFeePerGas?: HexString;
	// (undocumented)
	readonly difficulty?: HexString;
	// (undocumented)
	readonly gasLimit: HexString;
	// (undocumented)
	readonly gasUsed: HexString;
	// (undocumented)
	readonly miner?: HexString;
	// (undocumented)
	readonly number?: HexString;
	// (undocumented)
	readonly size: HexString;
	// (undocumented)
	readonly timestamp: HexString;
	// (undocumented)
	readonly totalDifficulty?: HexString;
	// (undocumented)
	readonly transactions?: TransactionInput[];
}

// @public (undocumented)
export interface BlockOutput {
	// (undocumented)
	readonly baseFeePerGas?: bigint | number;
	// (undocumented)
	readonly difficulty?: bigint | number;
	// (undocumented)
	readonly gasLimit: bigint | number;
	// (undocumented)
	readonly gasUsed: bigint | number;
	// (undocumented)
	readonly miner?: HexString;
	// (undocumented)
	readonly number?: bigint | number;
	// (undocumented)
	readonly parentHash?: HexString32Bytes;
	// (undocumented)
	readonly size: bigint | number;
	// (undocumented)
	readonly timestamp: bigint | number;
	// (undocumented)
	readonly totalDifficulty?: bigint | number;
	// (undocumented)
	readonly transactions?: TransactionOutput[];
}

// @public (undocumented)
export type ByteTypes = {
	[FMT_BYTES.HEX]: HexString;
	[FMT_BYTES.BUFFER]: Buffer;
	[FMT_BYTES.UINT8ARRAY]: Uint8Array;
};

// @public (undocumented)
export interface CompileResult {
	// (undocumented)
	readonly code: HexStringBytes;
	// (undocumented)
	readonly info: {
		readonly source: string;
		readonly language: string;
		readonly languageVersion: string;
		readonly compilerVersion: string;
		readonly abiDefinition: Record<string, unknown>[];
		readonly userDoc: {
			readonly methods: Record<string, unknown>;
		};
		readonly developerDoc: {
			readonly methods: Record<string, unknown>;
		};
	};
}

// @public (undocumented)
export type ConnectionEvent = {
	code: number;
	reason: string;
	wasClean?: boolean;
};

// @public (undocumented)
export const convert: (
	data: Record<string, unknown> | unknown[] | unknown,
	schema: JsonSchema,
	dataPath: string[],
	format: DataFormat,
) => unknown;

// @public (undocumented)
export const convertScalarValue: (value: unknown, ethType: string, format: DataFormat) => unknown;

// @public (undocumented)
export type DataFormat = {
	readonly number: FMT_NUMBER;
	readonly bytes: FMT_BYTES;
};

// @public (undocumented)
export const DEFAULT_RETURN_FORMAT: {
	readonly number: FMT_NUMBER.HEX;
	readonly bytes: FMT_BYTES.HEX;
};

// @public (undocumented)
export class DeferredPromise<T> implements Promise<T> {
	// (undocumented)
	[Symbol.toStringTag]: 'Promise';
	constructor({
		timeout,
		eagerStart,
		timeoutMessage,
	}?: {
		timeout: number;
		eagerStart: boolean;
		timeoutMessage: string;
	});
	// (undocumented)
	catch<TResult>(
		onrejected?: (reason: any) => TResult | PromiseLike<TResult>,
	): Promise<T | TResult>;
	// (undocumented)
	finally(onfinally?: (() => void) | null): Promise<T>;
	// (undocumented)
	reject(reason?: unknown): void;
	// (undocumented)
	resolve(value: T | PromiseLike<T>): void;
	// (undocumented)
	get state(): 'pending' | 'fulfilled' | 'rejected';
	// (undocumented)
	then<TResult1, TResult2>(
		onfulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
		onrejected?: (reason: unknown) => TResult2 | PromiseLike<TResult2>,
	): Promise<TResult1 | TResult2>;
}

// @public (undocumented)
export type EthExecutionAPI = {
	eth_getBlockByHash: (blockHash: HexString32Bytes, hydrated: boolean) => Block;
	eth_getBlockByNumber: (blockNumber: BlockNumberOrTag, hydrated: boolean) => Block;
	eth_getBlockTransactionCountByHash: (blockHash: HexString32Bytes) => Uint;
	eth_getBlockTransactionCountByNumber: (blockNumber: BlockNumberOrTag) => Uint;
	eth_getUncleCountByBlockHash: (blockHash: HexString32Bytes) => Uint;
	eth_getUncleCountByBlockNumber: (blockNumber: BlockNumberOrTag) => Uint;
	eth_getUncleByBlockHashAndIndex: (blockHash: HexString32Bytes, uncleIndex: Uint) => Block;
	eth_getUncleByBlockNumberAndIndex: (blockNumber: BlockNumberOrTag, uncleIndex: Uint) => Block;
	eth_getTransactionByHash: (transactionHash: HexString32Bytes) => TransactionInfo | null;
	eth_getTransactionByBlockHashAndIndex: (
		blockHash: HexString32Bytes,
		transactionIndex: Uint,
	) => TransactionInfo | null;
	eth_getTransactionByBlockNumberAndIndex: (
		blockNumber: BlockNumberOrTag,
		transactionIndex: Uint,
	) => TransactionInfo | null;
	eth_getTransactionReceipt: (transactionHash: HexString32Bytes) => ReceiptInfo | null;
	eth_protocolVersion: () => string;
	eth_syncing: () => SyncingStatus;
	eth_coinbase: () => Address;
	eth_accounts: () => Address[];
	eth_blockNumber: () => Uint;
	eth_call: (transaction: TransactionCall, blockNumber: BlockNumberOrTag) => HexStringBytes;
	eth_estimateGas: (
		transaction: Partial<TransactionWithSender>,
		blockNumber: BlockNumberOrTag,
	) => Uint;
	eth_gasPrice: () => Uint;
	eth_feeHistory: (
		blockCount: Uint,
		newestBlock: BlockNumberOrTag,
		rewardPercentiles: number[],
	) => FeeHistoryResult;
	eth_newFilter: (filter: Filter) => Uint;
	eth_newBlockFilter: () => Uint;
	eth_newPendingTransactionFilter: () => Uint;
	eth_uninstallFilter: (filterIdentifier: Uint) => boolean;
	eth_getFilterChanges: (filterIdentifier: Uint) => FilterResults;
	eth_getFilterLogs: (filterIdentifier: Uint) => FilterResults;
	eth_getLogs: (filter: Filter) => FilterResults;
	eth_mining: () => boolean;
	eth_hashrate: () => Uint;
	eth_getWork: () => [HexString32Bytes, HexString32Bytes, HexString32Bytes];
	eth_submitWork: (
		nonce: HexString8Bytes,
		hash: HexString32Bytes,
		digest: HexString32Bytes,
	) => boolean;
	eth_submitHashrate: (hashRate: HexString32Bytes, id: HexString32Bytes) => boolean;
	eth_sign: (address: Address, message: HexStringBytes) => HexString256Bytes;
	eth_signTransaction: (
		transaction: TransactionWithSender | Partial<TransactionWithSender>,
	) => HexStringBytes;
	eth_getBalance: (address: Address, blockNumber: BlockNumberOrTag) => Uint;
	eth_getStorageAt: (
		address: Address,
		storageSlot: Uint256,
		blockNumber: BlockNumberOrTag,
	) => HexStringBytes;
	eth_getTransactionCount: (address: Address, blockNumber: BlockNumberOrTag) => Uint;
	eth_getCode: (address: Address, blockNumber: BlockNumberOrTag) => HexStringBytes;
	eth_sendTransaction: (
		transaction: TransactionWithSender | Partial<TransactionWithSender>,
	) => HexString32Bytes;
	eth_sendRawTransaction: (transaction: HexStringBytes) => HexString32Bytes;
	eth_subscribe: (
		...params:
			| ['newHeads']
			| ['newPendingTransactions']
			| ['syncing']
			| [
					'logs',
					{
						address?: HexString;
						topics?: HexString[];
					},
			  ]
	) => HexString;
	eth_unsubscribe: (subscriptionId: HexString) => HexString;
	eth_clearSubscriptions: (keepSyncing?: boolean) => void;
	eth_getCompilers: () => string[];
	eth_compileSolidity: (code: string) => CompileResult;
	eth_compileLLL: (code: string) => HexStringBytes;
	eth_compileSerpent: (code: string) => HexStringBytes;
};

// @public (undocumented)
export interface FeeHistoryResult {
	// (undocumented)
	readonly baseFeePerGas: Uint;
	// (undocumented)
	readonly oldestBlock: Uint;
	// (undocumented)
	readonly reward: number[][];
}

// @public (undocumented)
export type FilterResults = HexString32Bytes[] | Log[];

// @public (undocumented)
export enum FMT_BYTES {
	// (undocumented)
	BUFFER = 'BYTES_BUFFER',
	// (undocumented)
	HEX = 'BYTES_HEX',
	// (undocumented)
	UINT8ARRAY = 'BYTES_UINT8ARRAY',
}

// @public (undocumented)
export enum FMT_NUMBER {
	// (undocumented)
	BIGINT = 'NUMBER_BIGINT',
	// (undocumented)
	HEX = 'NUMBER_HEX',
	// (undocumented)
	NUMBER = 'NUMBER_NUMBER',
	// (undocumented)
	STR = 'NUMBER_STR',
}

// @public (undocumented)
export const format: <DataType extends unknown, ReturnType_1 extends DataFormat>(
	schema: ValidationSchemaInput | JsonSchema,
	data: DataType,
	returnFormat: ReturnType_1,
) => FormatType<DataType, ReturnType_1>;

// @public (undocumented)
export type FormatType<T, F extends DataFormat> = number extends Extract<T, Numbers>
	? NumberTypes[F['number']] | Exclude<T, Numbers>
	: Buffer extends Extract<T, Bytes>
	? ByteTypes[F['bytes']] | Exclude<T, Bytes>
	: T extends object | undefined
	? {
			[P in keyof T]: FormatType<T[P], F>;
	  }
	: T;

// @public (undocumented)
export const inputAddressFormatter: (address: string) => string | never;

// @public (undocumented)
export const inputBlockNumberFormatter: (blockNumber: Numbers | undefined) => string | undefined;

// @public (undocumented)
export const inputCallFormatter: (
	options: TransactionInput,
	defaultAccount?: string | undefined,
) => Mutable<TransactionOutput>;

// @public (undocumented)
export const inputDefaultBlockNumberFormatter: (
	blockNumber: Numbers | undefined,
	defaultBlock: Numbers,
) => string | undefined;

// @public (undocumented)
export const inputLogFormatter: (filter: Filter) => Filter;

// @public (undocumented)
export const inputPostFormatter: (post: PostOutput) => PostInput;

// @public (undocumented)
export const inputSignFormatter: (data: string) => string;

// @public (undocumented)
export const inputStorageKeysFormatter: (keys: Array<string>) => string[];

// @public (undocumented)
export const inputTopicFormatter: (topic: Topic) => Topic | null;

// @public (undocumented)
export const inputTransactionFormatter: (
	options: TransactionInput,
	defaultAccount?: string | undefined,
) => Mutable<TransactionOutput>;

// @public (undocumented)
export class InvalidResponseError<ErrorType = unknown> extends ResponseError<ErrorType> {
	constructor(result: JsonRpcResponse<unknown, ErrorType>);
}

// @public (undocumented)
const isBatchRequest: (
	request: JsonRpcBatchRequest | JsonRpcRequest<unknown> | JsonRpcOptionalRequest<unknown>,
) => request is JsonRpcBatchRequest;

// @public (undocumented)
const isBatchResponse: <Result = unknown, Error_1 = unknown>(
	response: JsonRpcResponse<Result, Error_1>,
) => response is (JsonRpcResponseWithError<Error_1> | JsonRpcResponseWithResult<Result>)[];

// @public (undocumented)
const isResponseWithError: <Error_1 = unknown, Result = unknown>(
	response: JsonRpcResponse<Result, Error_1>,
) => response is JsonRpcResponseWithError<Error_1>;

// @public (undocumented)
const isResponseWithNotification: <Result>(
	response: JsonRpcSubscriptionResult | JsonRpcNotification<Result>,
) => response is JsonRpcNotification<Result>;

// @public (undocumented)
const isResponseWithResult: <Result = unknown, Error_1 = unknown>(
	response: JsonRpcResponse<Result, Error_1>,
) => response is JsonRpcResponseWithResult<Result>;

// @public (undocumented)
const isSubscriptionResult: <Result>(
	response: JsonRpcSubscriptionResult | JsonRpcNotification<Result>,
) => response is JsonRpcSubscriptionResult;

// @public (undocumented)
const isValidResponse: <Result = unknown, Error_1 = unknown>(
	response: JsonRpcResponse<Result, Error_1>,
) => boolean;

declare namespace jsonRpc {
	export {
		isResponseWithResult,
		isResponseWithError,
		isResponseWithNotification,
		isSubscriptionResult,
		validateResponse,
		isValidResponse,
		isBatchResponse,
		toPayload,
		toBatchPayload,
		isBatchRequest,
	};
}
export { jsonRpc };

// @public (undocumented)
export type JsonRpcBatchRequest = JsonRpcRequest[];

// @public (undocumented)
export type JsonRpcBatchResponse<Result = JsonRpcResult, Error = JsonRpcResult> = (
	| JsonRpcResponseWithError<Error>
	| JsonRpcResponseWithResult<Result>
)[];

// @public (undocumented)
export interface JsonRpcError<T = JsonRpcResult> {
	// (undocumented)
	readonly code: number;
	// (undocumented)
	readonly data?: T;
	// (undocumented)
	readonly message: string;
}

// @public (undocumented)
export type JsonRpcId = string | number | null;

// @public (undocumented)
export type JsonRpcIdentifier = string & ('2.0' | '1.0');

// @public (undocumented)
export interface JsonRpcNotification<T = JsonRpcResult> {
	// (undocumented)
	readonly id?: JsonRpcId;
	// (undocumented)
	readonly jsonrpc: JsonRpcIdentifier;
	// (undocumented)
	readonly method: string;
	// (undocumented)
	readonly params: SubscriptionParams<T>;
	// (undocumented)
	readonly result: never;
}

// @public (undocumented)
export interface JsonRpcOptionalRequest<ParamType = unknown[]>
	extends Omit<JsonRpcRequest<ParamType>, 'id' | 'jsonrpc'> {
	// (undocumented)
	readonly id?: JsonRpcId;
	// (undocumented)
	readonly jsonrpc?: JsonRpcIdentifier;
}

// @public (undocumented)
export type JsonRpcPayload<Param = unknown[]> = JsonRpcRequest<Param> | JsonRpcBatchRequest;

// @public (undocumented)
export interface JsonRpcRequest<T = unknown[]> {
	// (undocumented)
	readonly id: JsonRpcId;
	// (undocumented)
	readonly jsonrpc: JsonRpcIdentifier;
	// (undocumented)
	readonly method: string;
	// (undocumented)
	readonly params?: T;
}

// @public (undocumented)
export type JsonRpcResponse<Result = JsonRpcResult, Error = JsonRpcResult> =
	| JsonRpcResponseWithError<Error>
	| JsonRpcResponseWithResult<Result>
	| JsonRpcBatchResponse<Result, Error>;

// @public (undocumented)
export interface JsonRpcResponseWithError<Error = JsonRpcResult> {
	// (undocumented)
	readonly error: JsonRpcError<Error>;
	// (undocumented)
	readonly id: JsonRpcId;
	// (undocumented)
	readonly jsonrpc: JsonRpcIdentifier;
	// (undocumented)
	readonly result?: never;
}

// @public (undocumented)
export interface JsonRpcResponseWithResult<T = JsonRpcResult> {
	// (undocumented)
	readonly error?: never;
	// (undocumented)
	readonly id: JsonRpcId;
	// (undocumented)
	readonly jsonrpc: JsonRpcIdentifier;
	// (undocumented)
	readonly result: T;
}

// @public (undocumented)
export type JsonRpcResult = string | number | boolean | Record<string, unknown>;

// @public (undocumented)
export interface JsonRpcSubscriptionResult {
	// (undocumented)
	readonly id: number;
	// (undocumented)
	readonly jsonrpc: string;
	// (undocumented)
	readonly method: never;
	// (undocumented)
	readonly params: never;
	// (undocumented)
	readonly result: string;
}

// @public (undocumented)
export interface Log {
	// (undocumented)
	readonly address?: Address;
	// (undocumented)
	readonly blockHash?: HexString32Bytes | null;
	// (undocumented)
	readonly blockNumber?: Uint | null;
	// (undocumented)
	readonly data?: HexStringBytes;
	// (undocumented)
	readonly logIndex?: Uint | null;
	// (undocumented)
	readonly removed?: boolean;
	// (undocumented)
	readonly topics?: null | Topic | Topic[];
	// (undocumented)
	readonly transactionHash?: HexString32Bytes | null;
	// (undocumented)
	readonly transactionIndex?: Uint | null;
}

// @public (undocumented)
export interface LogsInput {
	// (undocumented)
	readonly address: HexString;
	// (undocumented)
	readonly blockHash?: HexString;
	// (undocumented)
	readonly blockNumber?: HexString;
	// (undocumented)
	readonly data: HexString;
	// (undocumented)
	readonly id?: string;
	// (undocumented)
	readonly logIndex?: HexString;
	// (undocumented)
	readonly topics: HexString[];
	// (undocumented)
	readonly transactionHash?: HexString;
	// (undocumented)
	readonly transactionIndex?: HexString;
}

// @public (undocumented)
export interface LogsOutput {
	// (undocumented)
	readonly address: string;
	// (undocumented)
	readonly blockHash: HexString32Bytes | null;
	// (undocumented)
	readonly blockNumber: bigint | number | null;
	// (undocumented)
	readonly data: HexString;
	// (undocumented)
	readonly id?: string;
	// (undocumented)
	readonly logIndex: bigint | number | null;
	// (undocumented)
	readonly removed: boolean;
	// (undocumented)
	readonly topics: HexString[];
	// (undocumented)
	readonly transactionHash: HexString32Bytes | null;
	// (undocumented)
	readonly transactionIndex?: bigint | number;
}

// @public (undocumented)
export type Mutable<T> = {
	-readonly [P in keyof T]: T[P];
};

// @public (undocumented)
export type NumberTypes = {
	[FMT_NUMBER.NUMBER]: number;
	[FMT_NUMBER.HEX]: HexString;
	[FMT_NUMBER.STR]: string;
	[FMT_NUMBER.BIGINT]: bigint;
};

// @public (undocumented)
export const outputBigIntegerFormatter: (number: Numbers) => number | bigint;

// @public (undocumented)
export const outputBlockFormatter: (block: BlockInput) => BlockOutput;

// @public (undocumented)
export const outputLogFormatter: (log: Partial<LogsInput>) => LogsOutput;

// @public (undocumented)
export const outputPostFormatter: (post: PostInput) => PostOutput;

// @public (undocumented)
export const outputProofFormatter: (proof: Proof) => Proof;

// @public (undocumented)
export const outputSyncingFormatter: (result: SyncInput) => SyncOutput;

// @public (undocumented)
export const outputTransactionFormatter: (tx: TransactionInput) => TransactionOutput;

// @public (undocumented)
export const outputTransactionReceiptFormatter: (receipt: ReceiptInput) => ReceiptOutput;

// @public (undocumented)
export interface PostInput {
	// (undocumented)
	readonly expiry?: HexString;
	// (undocumented)
	readonly priority?: HexString;
	// (undocumented)
	readonly sent?: HexString;
	// (undocumented)
	readonly topics?: HexString[];
	// (undocumented)
	readonly ttl?: HexString;
	// (undocumented)
	readonly workProved?: HexString;
	// (undocumented)
	readonly workToProve?: HexString;
}

// @public (undocumented)
export interface PostOutput {
	// (undocumented)
	readonly expiry?: bigint | number;
	// (undocumented)
	readonly priority?: bigint | number;
	// (undocumented)
	readonly sent?: bigint | number;
	// (undocumented)
	readonly topics?: string[];
	// (undocumented)
	readonly ttl?: bigint | number;
	// (undocumented)
	readonly workProved?: bigint | number;
	// (undocumented)
	readonly workToProve?: bigint | number;
}

// @public (undocumented)
export class PromiEvent<ResolveType, EventMap extends Web3EventMap>
	extends Web3EventEmitter<EventMap>
	implements Promise<ResolveType>
{
	// (undocumented)
	[Symbol.toStringTag]: 'Promise';
	constructor(executor: PromiseExecutor<ResolveType>);
	// (undocumented)
	catch<TResult = never>(
		onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,
	): Promise<ResolveType | TResult>;
	// (undocumented)
	finally(onfinally?: (() => void) | null): Promise<ResolveType>;
	// (undocumented)
	then<TResult1 = ResolveType, TResult2 = never>(
		onfulfilled?: ((value: ResolveType) => TResult1 | PromiseLike<TResult1>) | null,
		onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,
	): Promise<TResult1 | TResult2>;
}

// @public (undocumented)
export type PromiseExecutor<T> = (
	resolve: (data: T) => void,
	reject: (reason: unknown) => void,
) => void;

// @public (undocumented)
export const promiseTimeout: <T = void>(ms: number, message: string) => Promise<T>;

// @public (undocumented)
export interface Proof {
	// (undocumented)
	readonly address: HexString;
	// (undocumented)
	readonly balance: string;
	// (undocumented)
	readonly nonce: string;
}

// @public (undocumented)
export type Receipt = Record<string, unknown>;

// @public (undocumented)
export interface ReceiptInfo {
	// (undocumented)
	readonly blockHash: HexString32Bytes;
	// (undocumented)
	readonly blockNumber: Uint;
	// (undocumented)
	readonly contractAddress: Address | null;
	// (undocumented)
	readonly cumulativeGasUsed: Uint;
	// (undocumented)
	readonly effectiveGasPrice: Uint;
	// (undocumented)
	readonly from: Address;
	// (undocumented)
	readonly gasUsed: Uint;
	// (undocumented)
	readonly logs: Log[];
	// (undocumented)
	readonly logsBloom: HexString256Bytes;
	// (undocumented)
	readonly root: HexString32Bytes;
	// (undocumented)
	readonly status: '0x1' | '0x0';
	// (undocumented)
	readonly to: Address;
	// (undocumented)
	readonly transactionHash: HexString32Bytes;
	// (undocumented)
	readonly transactionIndex: Uint;
}

// @public (undocumented)
export interface ReceiptInput {
	// (undocumented)
	readonly [x: string]: unknown;
	// (undocumented)
	readonly blockNumber?: HexString;
	// (undocumented)
	readonly contractAddress?: HexString;
	// (undocumented)
	readonly cumulativeGasUsed: HexString;
	// (undocumented)
	readonly effectiveGasPrice?: HexString;
	// (undocumented)
	readonly gasUsed: HexString;
	// (undocumented)
	readonly logs?: LogsInput[];
	// (undocumented)
	readonly status?: string;
	// (undocumented)
	readonly transactionIndex?: HexString;
}

// @public (undocumented)
export interface ReceiptOutput {
	// (undocumented)
	readonly blockNumber?: bigint | number;
	// (undocumented)
	readonly contractAddress?: HexString;
	// (undocumented)
	readonly cumulativeGasUsed: bigint | number;
	// (undocumented)
	readonly effectiveGasPrice?: bigint | number;
	// (undocumented)
	readonly gasUsed: bigint | number;
	// (undocumented)
	readonly logs?: LogsOutput[];
	// (undocumented)
	readonly status: boolean;
	// (undocumented)
	readonly transactionIndex?: bigint | number;
}

// @public (undocumented)
export class ResponseError<ErrorType = unknown> extends Web3Error {
	constructor(response: JsonRpcResponse<unknown, ErrorType>, message?: string);
	// (undocumented)
	code: number;
	// (undocumented)
	data?: ErrorType | ErrorType[];
	// (undocumented)
	toJSON(): {
		data: ErrorType | ErrorType[] | undefined;
		name: string;
		code: number;
		message: string;
	};
}

// @public (undocumented)
export interface SubscriptionParams<T = JsonRpcResult> {
	// (undocumented)
	readonly result: T;
	// (undocumented)
	readonly subscription: string;
}

// @public (undocumented)
export type SyncingStatus =
	| {
			startingBlock: Uint;
			currentBlock: Uint;
			highestBlock: Uint;
	  }
	| boolean;

// @public (undocumented)
export interface SyncInput {
	// (undocumented)
	readonly currentBlock: HexString;
	// (undocumented)
	readonly highestBlock: HexString;
	// (undocumented)
	readonly knownStates?: HexString;
	// (undocumented)
	readonly pulledStates?: HexString;
	// (undocumented)
	readonly startingBlock: HexString;
}

// @public (undocumented)
export interface SyncOutput {
	// (undocumented)
	readonly currentBlock: bigint | number;
	// (undocumented)
	readonly highestBlock: bigint | number;
	// (undocumented)
	readonly knownStates?: bigint | number;
	// (undocumented)
	readonly pulledStates?: bigint | number;
	// (undocumented)
	readonly startingBlock: bigint | number;
}

// @public (undocumented)
const toBatchPayload: (requests: JsonRpcOptionalRequest<unknown>[]) => JsonRpcBatchRequest;

// @public (undocumented)
const toPayload: <ParamType = unknown[]>(
	request: JsonRpcOptionalRequest<ParamType>,
) => JsonRpcPayload<ParamType>;

// @public (undocumented)
export interface Transaction1559Signed extends Transaction1559Unsigned {
	// (undocumented)
	readonly r: Uint;
	// (undocumented)
	readonly s: Uint;
	// (undocumented)
	readonly yParity: Uint;
}

// @public (undocumented)
export interface Transaction1559Unsigned extends BaseTransaction {
	// (undocumented)
	readonly accessList: AccessList;
	// (undocumented)
	readonly maxFeePerGas: Uint;
	// (undocumented)
	readonly maxPriorityFeePerGas: Uint;
}

// @public (undocumented)
export interface Transaction2930Signed extends Transaction2930Unsigned {
	// (undocumented)
	readonly r: Uint;
	// (undocumented)
	readonly s: Uint;
	// (undocumented)
	readonly yParity: Uint;
}

// @public (undocumented)
export interface Transaction2930Unsigned extends BaseTransaction {
	// (undocumented)
	readonly accessList: AccessList;
	// (undocumented)
	readonly gasPrice: Uint;
}

// @public (undocumented)
export interface TransactionCall {
	// (undocumented)
	readonly accessList?: AccessList;
	// (undocumented)
	readonly data?: HexStringBytes;
	// (undocumented)
	readonly from?: Address;
	// (undocumented)
	readonly gas?: Uint;
	// (undocumented)
	readonly gasPrice?: Uint;
	// (undocumented)
	readonly maxFeePerGas?: Uint;
	// (undocumented)
	readonly maxPriorityFeePerGas?: Uint;
	// (undocumented)
	readonly to: Address;
	// (undocumented)
	readonly type?: HexStringSingleByte;
	// (undocumented)
	readonly value?: Uint;
}

// @public (undocumented)
export type TransactionHash = HexString;

// @public (undocumented)
export type TransactionInfo = TransactionSigned & {
	readonly blockHash: HexString32Bytes | null;
	readonly blockNumber: Uint | null;
	readonly from: Address;
	readonly hash: HexString32Bytes;
	readonly transactionIndex: Uint | null;
};

// @public (undocumented)
export interface TransactionInput {
	// (undocumented)
	readonly [key: string]: unknown;
	// (undocumented)
	readonly blockNumber?: HexString;
	// (undocumented)
	readonly chainId?: HexString;
	// (undocumented)
	readonly data?: string;
	// (undocumented)
	readonly from?: HexString;
	// (undocumented)
	readonly gas: HexString;
	// (undocumented)
	readonly gasLimit?: string;
	// (undocumented)
	readonly gasPrice?: string;
	// (undocumented)
	readonly input?: string;
	// (undocumented)
	readonly maxFeePerGas?: string;
	// (undocumented)
	readonly maxPriorityFeePerGas?: string;
	// (undocumented)
	readonly nonce: string;
	// (undocumented)
	readonly to?: HexString;
	// (undocumented)
	readonly transactionIndex?: HexString;
	// (undocumented)
	readonly type?: HexString;
	// (undocumented)
	readonly value: string;
}

// @public (undocumented)
export interface TransactionLegacySigned extends TransactionLegacyUnsigned {
	// (undocumented)
	readonly r: Uint;
	// (undocumented)
	readonly s: Uint;
	// (undocumented)
	readonly v: Uint;
}

// @public (undocumented)
export interface TransactionLegacyUnsigned extends BaseTransaction {
	// (undocumented)
	readonly gasPrice: Uint;
}

// @public (undocumented)
export type TransactionOutput = {
	readonly [key: string]: unknown;
	readonly to?: HexString;
	readonly from?: HexString;
	readonly data: string;
	readonly gas?: bigint | number;
	readonly gasLimit?: string;
	readonly nonce: bigint | number;
	readonly value: bigint | number;
	readonly blockNumber?: bigint | number;
	readonly transactionIndex?: bigint | number;
} & (
	| {
			maxPriorityFeePerGas: bigint | number;
			maxFeePerGas: bigint | number;
			gasPrice?: never;
	  }
	| {
			maxPriorityFeePerGas?: never;
			maxFeePerGas?: never;
			gasPrice: bigint | number;
	  }
);

// @public (undocumented)
export type TransactionSigned =
	| Transaction1559Signed
	| Transaction2930Signed
	| TransactionLegacySigned;

// @public (undocumented)
export type TransactionUnsigned =
	| Transaction1559Unsigned
	| Transaction2930Unsigned
	| TransactionLegacyUnsigned;

// @public (undocumented)
export type TransactionWithSender = TransactionUnsigned & {
	from: Address;
};

// @public (undocumented)
export const txInputOptionsFormatter: (options: TransactionInput) => Mutable<TransactionOutput>;

// @public (undocumented)
export type Uncles = HexString32Bytes[];

// @public (undocumented)
const validateResponse: <Result = unknown, Error_1 = unknown>(
	response: JsonRpcResponse<Result, Error_1>,
) => boolean;

// @public (undocumented)
export interface Web3AccountProvider<T> {
	// (undocumented)
	create: () => T;
	// (undocumented)
	decrypt: (keystore: string, password: string, options?: Record<string, unknown>) => Promise<T>;
	// (undocumented)
	privateKeyToAccount: (privateKey: string) => T;
}

// @public (undocumented)
export type Web3APIMethod<T extends Web3APISpec> = string & keyof T;

// @public (undocumented)
export type Web3APIParams<API extends Web3APISpec, Method extends Web3APIMethod<API>> = Parameters<
	API[Method]
>;

// @public (undocumented)
export interface Web3APIPayload<API extends Web3APISpec, Method extends Web3APIMethod<API>>
	extends Web3APIRequest<API, Method> {
	// (undocumented)
	readonly id?: JsonRpcId;
	// (undocumented)
	readonly jsonrpc?: JsonRpcIdentifier;
}

// @public (undocumented)
export interface Web3APIRequest<API extends Web3APISpec, Method extends Web3APIMethod<API>> {
	// (undocumented)
	method: Method;
	// (undocumented)
	params: Web3APIParams<API, Method>;
}

// @public (undocumented)
export type Web3APIReturnType<
	API extends Web3APISpec,
	Method extends Web3APIMethod<API>,
> = ReturnType<API[Method]>;

// @public (undocumented)
export type Web3APISpec = Record<string, (...params: any) => any>;

// @public (undocumented)
export abstract class Web3BaseProvider<API extends Web3APISpec = EthExecutionAPI> {
	// (undocumented)
	get [symbol](): boolean;
	// (undocumented)
	abstract connect(): void;
	// (undocumented)
	abstract disconnect(code: number, reason: string): void;
	// (undocumented)
	abstract getStatus(): Web3BaseProviderStatus;
	// (undocumented)
	static isWeb3Provider(provider: unknown): boolean;
	// (undocumented)
	abstract on<T = JsonRpcResult>(
		type: 'message' | 'disconnect' | string,
		callback: Web3BaseProviderCallback<T>,
	): void;
	// (undocumented)
	abstract on(
		type: 'connect' | 'chainChanged',
		callback: Web3BaseProviderCallback<{
			readonly [key: string]: unknown;
			readonly chainId: string;
		}>,
	): void;
	// (undocumented)
	abstract on(
		type: 'accountsChanged',
		callback: Web3BaseProviderCallback<{
			readonly [key: string]: unknown;
			readonly accountsChanged: string[];
		}>,
	): void;
	// (undocumented)
	abstract once?<T = JsonRpcResult>(type: string, callback: Web3BaseProviderCallback<T>): void;
	// (undocumented)
	abstract removeAllListeners?(type: string): void;
	// (undocumented)
	abstract removeListener(type: string, callback: Web3BaseProviderCallback): void;
	// (undocumented)
	abstract request<
		Method extends Web3APIMethod<API>,
		ResponseType = Web3APIReturnType<API, Method>,
	>(
		request: Web3APIPayload<API, Method>,
		requestOptions?: unknown,
	): Promise<JsonRpcResponse<ResponseType>>;
	// (undocumented)
	abstract reset(): void;
	// (undocumented)
	abstract supportsSubscriptions(): boolean;
}

// @public (undocumented)
export type Web3BaseProviderCallback<T = JsonRpcResult> = (
	error: Error | null,
	result?: JsonRpcSubscriptionResult | JsonRpcNotification<T>,
) => void;

// @public (undocumented)
export type Web3BaseProviderStatus = 'connecting' | 'connected' | 'disconnected';

// @public (undocumented)
export abstract class Web3BaseWallet<T extends Web3BaseWalletAccount> {
	constructor(accountProvider: Web3AccountProvider<T>);
	// (undocumented)
	protected readonly _accountProvider: Web3AccountProvider<T>;
	// (undocumented)
	abstract add(account: T | string): boolean;
	// (undocumented)
	abstract clear(): this;
	// (undocumented)
	abstract create(numberOfAccounts: number): this;
	// (undocumented)
	abstract decrypt(
		encryptedWallet: Web3EncryptedWallet[],
		password: string,
		options?: Record<string, unknown>,
	): Promise<this>;
	// (undocumented)
	abstract encrypt(
		password: string,
		options?: Record<string, unknown>,
	): Promise<Web3EncryptedWallet[]>;
	// (undocumented)
	abstract get(addressOrIndex: string | number): T;
	// (undocumented)
	abstract load(password: string, keyName?: string): Promise<this | never>;
	// (undocumented)
	abstract remove(addressOrIndex: string | number): boolean;
	// (undocumented)
	abstract save(password: string, keyName?: string): Promise<boolean | never>;
}

// @public (undocumented)
export interface Web3BaseWalletAccount {
	// (undocumented)
	[key: string]: unknown;
	// (undocumented)
	readonly address: string;
	// (undocumented)
	readonly encrypt: (
		password: string,
		options?: Record<string, unknown>,
	) => Promise<Web3EncryptedWallet>;
	// (undocumented)
	readonly privateKey: string;
	// (undocumented)
	readonly sign: (data: Record<string, unknown> | string) => {
		readonly messageHash: HexString;
		readonly r: HexString;
		readonly s: HexString;
		readonly v: HexString;
		readonly message?: string;
		readonly signature: HexString;
	};
	// (undocumented)
	readonly signTransaction: (tx: Record<string, unknown>) => {
		readonly messageHash: HexString;
		readonly r: HexString;
		readonly s: HexString;
		readonly v: HexString;
		readonly rawTransaction: HexString;
		readonly transactionHash: HexString;
	};
}

// @public (undocumented)
export interface Web3Emitter<T extends Web3EventMap> {
	// (undocumented)
	emit<K extends Web3EventKey<T>>(eventName: K, params: T[K]): void;
	// (undocumented)
	off<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
	// (undocumented)
	on<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
	// (undocumented)
	once<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
}

// @public (undocumented)
export type Web3EncryptedWallet = string;

// @public (undocumented)
export type Web3EventCallback<T> = (params: T) => void | Promise<void>;

// @public (undocumented)
export class Web3EventEmitter<T extends Web3EventMap> implements Web3Emitter<T> {
	// (undocumented)
	emit<K extends Web3EventKey<T>>(eventName: K, params: T[K]): void;
	// (undocumented)
	eventNames(): (string | symbol)[];
	// (undocumented)
	listenerCount<K extends Web3EventKey<T>>(eventName: K): number;
	// (undocumented)
	listeners<K extends Web3EventKey<T>>(eventName: K): Function[];
	// (undocumented)
	off<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
	// (undocumented)
	on<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
	// (undocumented)
	once<K extends Web3EventKey<T>>(eventName: K, fn: Web3EventCallback<T[K]>): void;
	// (undocumented)
	removeAllListeners(): EventEmitter;
}

// @public (undocumented)
export type Web3EventKey<T extends Web3EventMap> = string & keyof T;

// @public (undocumented)
export type Web3EventMap = Record<string, unknown>;

// (No @packageDocumentation comment for this package)
```
